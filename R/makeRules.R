#' Create AMR Rules Based on Geno-Pheno Data
#'
#' This function generates AMRrules based on genotype-phenotype data.
#' The rules are created initially for single markers using solo PPV and median MIC/disk assay data in comparison to
#' the defined breakpoints and ECOFFs (either user-specified, or retrieved using the AMR package), and then
#' rules for combinations of markers are added if the phenotypes associated with the combination are more resistant
#' (R>I>S, nonwildtype>wildtype) than for the individual component markers.
#'
#' @param amrrules A list containing AMR analysis results, generated by `amrrules_analysis`.
#' @param minObs Minimum number of observations (samples) required for a given marker/combination, in order for PPV or assay data to be considered in rule setting. Default is 3.
#' @param low_threshold Minimum number of observations required for `evidence grade` to be assigned as "moderate" rather than "low". Default is 20.
#' @param core_threshold The threshold used to classify a gene as "core" based on its frequency in the sample set. Default is 0.9 (90%).
#' @param mic_S The MIC S breakpoint. If `NULL`, breakpoints will be retrieved using the AMR package.
#' @param mic_R The MIC R breakpoint. If `NULL`, breakpoints will be retrieved using the AMR package
#' @param use_mic Logical indicating whether to use MIC data in rule generation. Default is `TRUE`.
#' @param mic_ecoff The MIC ECOFF for the antibiotic, used to define nonwildtype. If `NULL`, ECOFF will be retrieved using the AMR package.
#' @param use_disk Logical indicating whether to use disk diffusion data for rule generation. Default is `TRUE`.
#' @param disk_S The disk diffusion S breakpoint. If `NULL`, breakpoints will be retrieved using the AMR package.
#' @param disk_R The disk diffusion R breakpoint. If `NULL`, breakpoints will be retrieved using the AMR package.
#' @param disk_ecoff The disk diffusion ECOFF for the antibiotic, used to define nonwildtype. If `NULL`, ECOFF will be retrieved using the AMR package.
#' @param guide The guideline to use for breakpoints, when retrieving these from the AMR package. Default is `"EUCAST 2025"`.
#' @param bp_site Site of infection, used if multiple breakpoint values are available for different body sites.
#' @param rule_prefix Prefix for the generated rule IDs. If `NULL`, prefix will be assigned based on the species name.
#' @param ruleID_start The starting ID number for generated rules. Default is 1000.
#' @param note_prefix Prefix for the note describing the method used to create the rules. Default is `"Quantitative geno-pheno analysis by ESGEM-AMR WG"`.
#' @param regression Logical indicating whether to consider logistic regression data (only used to define wildtype S for an individual marker, where the p-value exceeds 0.05 and odds ratio crosses 0, and there is no solo-marker data available). Default is `TRUE`.
#'
#' @return A list containing 2 data frames:
#'   - `rules`: The draft rules in AMRrules format (spec v0.6), with some additional quantitative data fields to support review.
#'   - `data`: Full set of quantitative data fields used to draft the rules.
#'
#' @details
#' The `makerules` function generates AMR rules based on quantitative analysis of genotype vs phenotype data.
#' The rules can be based on MIC or disk diffusion assay results, and different thresholds are applied to assign
#' evidence grades and limitations based on the quantiative data available, according to the AMRrules v0.5 specification.
#' A detailed `rule curation note` is included in the output `rules` dataframe, summarising the quantitative
#' data supporting each rule.
#' Full data on each marker/combination is also returned in the separate `data` dataframe.
#'
#' @examples
#' \dontrun{
#' # Example of creating AMR rules
#' amrrules <- amrrules_analysis(geno_table, pheno_table, antibiotic = "Ciprofloxacin",
#'                               drug_class_list = c("Quinolones"), species = "E. coli")
#' rules <- makerules(amrrules)
#' }
#'
#' @seealso
#' \code{\link{amrrules_analysis}} for generating the AMR analysis data that is input into `makerules`.
#'
#' @import dplyr
#' @import ggplot2
#' @importFrom AMR as.ab as.mo
#'
#' @export
makerules <- function(amrrules, minObs=3, low_threshold=20, core_threshold=0.9,
                      use_mic=TRUE, mic_S=NULL, mic_R=NULL, mic_ecoff=NULL,
                      use_disk=TRUE, disk_S=NULL, disk_R=NULL, disk_ecoff=NULL,
                      guide="EUCAST 2025", bp_site=NULL, rule_prefix=NULL, ruleID_start=1000,
                      note_prefix="Quantitative geno-pheno analysis by ESGEM-AMR WG",
                      regression=TRUE) {

  ## setup

  antibiotic <- amrrules$antibiotic

  species <- amrrules$species

  cat(paste("Generating AMRrules for", antibiotic, "in", species,"\n"))

  cat(" Checking parameters\n")
  check_ruleID_start <- as.integer(ruleID_start)
  if(is.na(check_ruleID_start)) {stop(paste("Need valid integer to start numbering rules, specified via 'ruleID_start':", ruleID_start,"is not valid"))}

  # check if we have a valid ruleID prefix
  if(is.null(rule_prefix)) {
    rule_prefix <- organism_codes %>% filter(mo==as.mo(species)) %>% pull(Prefix) # try using species
    if (is_empty(rule_prefix)) {
      genus <- microorganisms %>% filter(mo==as.mo(species)) %>% pull(genus) # try using genus
      rule_prefix <- organism_codes %>% filter(mo==as.mo(genus)) %>% pull(Prefix)
    }
    if (is_empty(rule_prefix)) {
      stop(paste("Could not determine valid rule ID prefix to use based on the species name:", species, "- please specify directly using 'rule_prefix'"))
    }
    else{cat(paste("  Determined rule ID prefix:",rule_prefix,"\n"))}
  }
  else{cat(paste("  Using user-specified rule ID prefix:",rule_prefix,"\n"))}

  bp_standard_mic <- bp_site
  bp_standard_disk <- bp_site

  # retrieve MIC breakpoints/ECOFF if needed
  if (use_mic) {

    # check we have MIC data
    if (is.null(amrrules$upset_mic_summary)) {
      cat("  WARNING: 'use_mic' set to TRUE but there are is no MIC summary data ($upset_mic_summary) in the input object\n")
      use_mic <- FALSE
    } else if (nrow(amrrules$upset_mic_summary %>% filter(marker_count>0))==0) {
      cat("  WARNING: 'use_mic' set to TRUE but the MIC summary data ($upset_mic_summary) in the input object is empty\n")
      use_mic <- FALSE
    }
  }

  if (use_mic) {
    if (is.null(mic_S) | is.null(mic_R)) { # determine MIC breakpoints
      bp <-checkBreakpoints(species, guide, antibiotic, bp_site, assay="MIC")
      mic_S <- bp$breakpoint_S
      mic_R <- bp$breakpoint_R
      bp_standard_mic <- bp$bp_standard
    }
    else{cat(paste("  Using user-specified MIC breakpoints: S <=", mic_S,"and R >", mic_R,"\n"))}

    if (is.null(mic_ecoff)) { # determine MIC ECOFF
      ecoffs <- getBreakpoints(species, guide, antibiotic, "ECOFF") %>% filter(method=="MIC")
      if (nrow(ecoffs)==0) {
        cat("  Could not determine MIC ECOFF using AMR package, using S breakpoint, consider providing your own value via 'mic_ecoff'\n")
        mic_ecoff <- mic_S
      }
      else {
        mic_ecoff <- ecoffs %>% pull(breakpoint_S) %>% first()
        if (is.na(mic_ecoff)) {
          cat("  Could not determine MIC ECOFF using AMR package, using S breakpoint, consider providing your own value via 'mic_ecoff'\n")
          mic_ecoff <- mic_S
        }
        else{cat(paste("  MIC ECOFF determined using AMR package:", mic_ecoff,"\n"))}
      }
    }
    else{cat(paste("  Using user-specified MIC ECOFF:", mic_ecoff,"\n"))}
  }

  # retrieve disk breakpoints/ECOFF if needed
  if (use_disk) {

    # check we have disk data - don't stop but warn, and set use_disk to false if none available
    if (is.null(amrrules$upset_disk_summary)) {
      cat("  WARNING: 'use_disk' set to TRUE but there are is no disk summary data ($upset_disk_summary) in the input object\n")
      use_disk=F
    }
    else if (nrow(amrrules$upset_disk_summary %>% filter(marker_count>0))==0) {
      cat("  WARNING: 'use_disk' set to TRUE but the disk summary data ($upset_disk_summary) in the input object is empty\n")
      use_disk=F
    }
  }

  if (use_disk) {

    if (is.null(disk_S) | is.null(disk_R)) { # determine disk diffusion breakpoints
      bp <-checkBreakpoints(species, guide, antibiotic, bp_site, assay="DISK")
      disk_S <- bp$breakpoint_S
      disk_R <- bp$breakpoint_R
      bp_standard_disk <- bp$bp_standard
    }
    else{cat(paste("  Using user-specified disk breakpoints: S >=", disk_S,"and R <", disk_R,"\n"))}

    if (is.null(disk_ecoff)) { # determine disk ECOFF
      ecoffs <- getBreakpoints(species, guide, antibiotic, "ECOFF") %>% filter(method=="DISK")
      if (nrow(ecoffs)==0) {
        cat("  Could not determine disk ECOFF using AMR package, using S breakpoint, consider providing your own value via 'disk_ecoff'\n")
        disk_ecoff <- disk_S
      }
      else {
        disk_ecoff <- ecoffs %>% pull(breakpoint_S) %>% first()
        if (is.na(disk_ecoff)) {
          cat("  Could not determine disk ECOFF using AMR package, using S breakpoint, consider providing your own value via 'disk_ecoff'\n")
          disk_ecoff <- disk_S
        }
        else{cat(paste("  Disk ECOFF determined using AMR package:", disk_ecoff,"\n"))}
      }
    }
    else{cat(paste("  Using user-specified disk ECOFF:", disk_ecoff,"\n"))}
  }

  if (is.null(bp_standard_mic)) {bp_standard_mic <- NA}
  if (is.null(bp_standard_disk)) {bp_standard_disk <- NA}

  # check if this drug is an expected R or I in this species
  expected_R <- as.ab(antibiotic) %in% (AMR::intrinsic_resistant %>% filter(mo==as.mo(species)) %>% pull(ab))
  if (expected_R) {cat(paste(" ",antibiotic,"is an expected resistance for",species,"\n"))}

  expected_I <- FALSE
  if(!expected_R) { # if expected I, the MIC S breakpoint is set to 0.001 (i.e. there is effectively no S category as all isolates exceed this value)
    if (!is.null(mic_S)) {if (mic_S==0.001) {expected_I <- TRUE}}
    if (!is.null(disk_S)) {if (disk_S==50) {expected_I <- TRUE}}
  }
  if (expected_I) {cat(paste(" ",antibiotic,"is an expected I for",species, "(there is no S category)\n"))}


  ## load quantitative data

  cat(" Loading solo PPV data\n")

  # solo PPV from combined mic/disk
  if (is.null(amrrules$solo_stats)) {
    stop(paste0("amrrules object ", deparse(substitute(amrrules)), " is missing $solo_stats\n"))
  } else {
    cat("  Loading solo PPV data from primary dataset with mic/disk measures\n")
  }

  data <- amrrules$solo_stats %>%
    mutate(note=paste0(category," solo PPV=", round(ppv,2)*100, "% (",x,"/",n,"). ")) %>%
    pivot_wider(id_cols=marker, names_from=category, values_from=c(ppv, x, n, ci.lower, ci.upper, note),
                                              names_glue= "{category}.solo.{.value}") %>%
    categorise_from_PPV(suffix="_soloPPV")

  if (!("R.solo.n" %in% colnames(data))) { data$R.solo.n <- 0 }
  if (!("NWT.solo.n" %in% colnames(data))) { data$NWT.solo.n <- 0 }

  if (!is.null(amrrules$solo_stats_all)) {
    cat("  ...adding solo PPV data from extended dataset including SIR calls with no mic/disk measures\n")
    solo_sir <- amrrules$solo_stats_all %>%
      mutate(note=paste0(category," extended solo PPV=", round(ppv,2)*100, "% (",x,"/",n,"). ")) %>%
      pivot_wider(id_cols=marker, names_from=category, values_from=c(ppv, x, n, ci.lower, ci.upper, note),
                names_glue= "{category}.soloExt.{.value}") %>%
      categorise_from_PPV(suffix="_soloExtPPV")
    data <- data %>% full_join(solo_sir, by="marker")
  } else{
    data <- data %>% mutate(category_soloExtPPV=NA) %>% category(phenotype_soloExtPPV=NA)
  }

  if (!("R.soloExt.n" %in% colnames(data))) { data$R.soloExt.n <- 0 }
  if (!("NWT.soloExt.n" %in% colnames(data))) { data$NWT.soloExt.n <- 0 }

  # regression data
  if (regression) {
    if (!is.null(amrrules$modelR) | !is.null(amrrules$modelNWT)) {
      cat(" Loading regression data from primary dataset with mic/disk measures\n")
      if (!is.null(amrrules$modelR)) {
        cat ("  ...R ")
        logreg_data <- amrrules$modelR %>%
          filter(marker!="(Intercept)") %>%
          rename_with(~paste0("R.logreg.", .x))
        data <- data %>% full_join(logreg_data, join_by(marker==R.logreg.marker)) %>%
          mutate(category_logReg=if_else(R.logreg.ci.lower<0 & R.logreg.ci.upper>0, "S", NA)) %>%
          mutate(category_logReg = if_else(category_logReg=="S" & expected_I, "I", category_logReg))
      }
      if (!is.null(amrrules$modelNWT)) {
        cat ("  ...NWT ")
        logreg_data <- amrrules$modelNWT %>%
          filter(marker!="(Intercept)") %>%
          rename_with(~paste0("NWT.logreg.", .x))
        data <- data %>% full_join(logreg_data, join_by(marker==NWT.logreg.marker)) %>%
          mutate(phenotype_logReg=if_else(NWT.logreg.ci.lower<0 & NWT.logreg.ci.upper>0, "WT", NA))
      }
      cat("\n")
    } else { cat("  No regression data found from primary dataset with mic/disk measures\n")}

    if (!is.null(amrrules$modelR_all) | !is.null(amrrules$modelNWT_all)) {
      cat(" Loading regression data from extended dataset including SIR calls with no mic/disk measures\n")
      if (!is.null(amrrules$modelR_all)) {
        cat ("  ...R ")
        logreg_data <- amrrules$modelR_all %>%
          filter(marker!="(Intercept)") %>%
          rename_with(~paste0("R.logregExt.", .x))
        data <- data %>% full_join(logreg_data, join_by(marker==R.logregExt.marker)) %>%
          mutate(category_logRegExt=if_else(R.logregExt.ci.lower<0 & R.logregExt.ci.upper>0, "S", NA)) %>%
          mutate(category_logRegExt = if_else(category_logRegExt=="S" & expected_I, "I", category_logRegExt))
      }
      if (!is.null(amrrules$modelNWT)) {
        cat ("  ...NWT ")
        logreg_data <- amrrules$modelNWT %>%
          filter(marker!="(Intercept)") %>%
          rename_with(~paste0("NWT.logregExt.", .x))
        data <- data %>% full_join(logreg_data, join_by(marker==NWT.logregExt.marker)) %>%
          mutate(phenotype_logRegExt=if_else(NWT.logregExt.ci.lower<0 & NWT.logregExt.ci.upper>0, "WT", NA))
      }
      cat("\n")
    } else {
      cat("  No regression data found from extended dataset including SIR calls with no mic/disk measures\n")
    }
    if (is.null(amrrules$modelR) & is.null(amrrules$modelNWT) & is.null(amrrules$modelR_all) & is.null(amrrules$modelNWT_all)) {
      cat("  No regression data at all in input\n")
      regression <- FALSE
    }
  }
  if (!("category_logReg" %in% colnames(data))) {data$category_logReg=NA}
  if (!("phenotype_logReg" %in% colnames(data))) {data$phenotype_logReg=NA}
  if (!("category_logRegExt" %in% colnames(data))) {data$category_logRegExt=NA}
  if (!("phenotype_logRegExt" %in% colnames(data))) {data$phenotype_logRegExt=NA}

  # add MIC data (PPV, median, for each marker/combination)

  if (use_mic & !is.null(amrrules$upset_mic_summary)) {
    cat(" Loading MIC data\n")
    # if more than half the values are expressed as ranges, ignore these and use median value calculated after excluding them
    mic_data <- amrrules$upset_mic_summary %>%
      filter(marker_list!="") %>%
      rename_with(~paste0("MIC.", .x)) %>%
      mutate(MIC.median=if_else(MIC.n_excludeRangeValues/MIC.n < 0.5, MIC.median_excludeRangeValues, MIC.median_ignoreRanges)) %>%
      mutate(MIC.q25=if_else(MIC.n_excludeRangeValues/MIC.n < 0.5, MIC.q25_excludeRangeValues, MIC.q25_ignoreRanges)) %>%
      mutate(MIC.q75=if_else(MIC.n_excludeRangeValues/MIC.n < 0.5, MIC.q75_excludeRangeValues, MIC.q75_ignoreRanges)) %>%
      mutate(mic_note=paste0("MIC: median ",MIC.median," [IQR ",MIC.q25,"-",MIC.q75,"]","; n=")) %>%
      mutate(mic_note=if_else(MIC.n_excludeRangeValues/MIC.n < 0.5,
                              paste0(mic_note,MIC.n_excludeRangeValues," (excluding ", MIC.n-MIC.n_excludeRangeValues," values expressed as ranges). "),
                              paste0(mic_note,MIC.n," (including ", MIC.n-MIC.n_excludeRangeValues," expressed as ranges. ")
                              ))
    if ("MIC.R.ppv" %in% colnames(mic_data)) {mic_data <- mic_data %>% rename(R.MIC.ppv=MIC.R.ppv)}
    if ("MIC.I.ppv" %in% colnames(mic_data)) {mic_data <- mic_data %>% rename(I.MIC.ppv=MIC.I.ppv)}
    if ("MIC.NWT.ppv" %in% colnames(mic_data)) {mic_data <- mic_data %>% rename(NWT.MIC.ppv=MIC.NWT.ppv)}
    mic_data <- mic_data %>%
      categorise_from_PPV(suffix="_micPPV")
    data <- data %>% full_join(mic_data, join_by(marker==MIC.marker_list))
  }
  else {
    use_mic <- FALSE
    data <- data %>% mutate(category_micPPV=NA) %>% mutate(phenotype_micPPV=NA) %>% mutate(MIC.n=0)
  }

  # add disk data (PPV, median, for each marker/combination)
  if (use_disk & !is.null(amrrules$upset_disk_summary)) {
    cat(" Loading disk data\n")
    disk_data <- amrrules$upset_disk_summary %>%
      filter(marker_list!="") %>%
      rename_with(~paste0("Disk.", .x)) %>%
      mutate(disk_note=paste0("Disk: median ",Disk.median," [IQR ",Disk.q25,"-",Disk.q75,"]","; n=",Disk.n, ". "))
    if ("Disk.R.ppv" %in% colnames(disk_data)) {disk_data <- disk_data %>% rename(R.Disk.ppv=Disk.R.ppv)}
    if ("Disk.I.ppv" %in% colnames(disk_data)) {disk_data <- disk_data %>% rename(I.Disk.ppv=Disk.I.ppv)}
    if ("Disk.NWT.ppv" %in% colnames(disk_data)) {disk_data <- disk_data %>% rename(NWT.Disk.ppv=Disk.NWT.ppv)}
    disk_data <- disk_data %>%
      categorise_from_PPV(suffix="_diskPPV")
    data <- data %>% full_join(disk_data, join_by(marker==Disk.marker_list))
  }
  else {
    use_disk <- FALSE
    data <- data %>% mutate(category_diskPPV=NA) %>% mutate(phenotype_diskPPV=NA) %>% mutate(Disk.n=0)
  }

  # add rules for any markers detected, but not already accounted for
  marker_hit_count <- amrrules$amr_binary_all %>%
    select(-any_of(c("id", "mic", "disk", "R", "I", "NWT", "pheno", "ecoff", "source"))) %>%
    colSums()
  full_marker_list <- gsub("\\.\\.", ":", names(marker_hit_count)) # convert mutations from .. to :

  blank_rules <- tibble(marker = full_marker_list) %>%
    filter(!(marker %in% data$marker))

  data <- data %>% bind_rows(blank_rules) %>%
    mutate(marker_count = str_count(marker, ",")+1)

  ## define categories and phenotypes using the collated data

  cat(" Comparing clinical categories\n")

  # if expected R, annotate R calls as wildtype and flag others for review
  if (expected_R) {
    data <- data %>% mutate(phenotype_soloPPV=if_else(category_soloPPV=="R", "WT", "REVIEW: expected R")) # R:wt, S/I:review
  }
  # if expected I, annotate I/R calls as wildtype and flag others for review
  else if (expected_I) {
    data <- data %>% mutate(phenotype_soloPPV=if_else(category_soloPPV  %in% c("I", "R"), "WT", "REVIEW: expected I")) # I/R:wt, S:review
  }

  ## compare calls from different analyses, note discrepancies
  # pay attention to numbers from different analyses, and if they pass minObs
  # assign call based on solo PPV first, where available

  cat(" Comparing calls from different sources\n")

  # set counts to zero for missing metrics
  data <- data %>%
    mutate(R.solo.n=if_else(is.na(R.solo.n), 0, R.solo.n)) %>%
    mutate(R.soloExt.n=if_else(is.na(R.soloExt.n), 0, R.soloExt.n)) %>%
    mutate(NWT.solo.n=if_else(is.na(NWT.solo.n), 0, NWT.solo.n)) %>%
    mutate(NWT.soloExt.n=if_else(is.na(NWT.soloExt.n), 0, NWT.soloExt.n)) %>%
    mutate(MIC.n=if_else(is.na(MIC.n), 0, MIC.n)) %>%
    mutate(Disk.n=if_else(is.na(Disk.n), 0, Disk.n))

  # category call from PPV data
  data <- data %>%
    rowwise() %>%
    mutate(results=list(compare_categories(category_soloPPV=category_soloPPV,
                                           category_soloExtPPV=category_soloExtPPV,
                                           category_micPPV=category_micPPV,
                                           category_diskPPV=category_diskPPV,
                                           category_logReg=category_logReg,
                                           category_logRegExt=category_logRegExt,
                                           R.solo.n=R.solo.n, R.soloExt.n=R.soloExt.n,
                                           MIC.n=MIC.n, Disk.n=Disk.n,
                                           minObs=minObs, low_threshold=low_threshold))) %>%
    ungroup() %>%
    unnest_wider(results) %>% # add fields category, grade, limitations_list, breakpoints_source
    rename(`clinical category`=category) %>%
    rename(category_limitations_list=limitations_list) %>%
    rename(category_grade=grade) %>%
    rename(category_breakpoints_source=breakpoints_source) %>%
    rename(category_note=note)

  # phenotype call from PPV data
  data <- data %>%
    rowwise() %>%
    mutate(results=list(compare_categories(category_soloPPV=phenotype_soloPPV,
                                           category_soloExtPPV=phenotype_soloExtPPV,
                                           category_micPPV=phenotype_micPPV,
                                           category_diskPPV=phenotype_diskPPV,
                                           category_logReg=phenotype_logReg,
                                           category_logRegExt=phenotype_logRegExt,
                                           R.solo.n=NWT.solo.n, R.soloExt.n=NWT.soloExt.n,
                                           MIC.n=MIC.n, Disk.n=Disk.n,
                                           minObs=minObs, low_threshold=low_threshold))) %>%
    ungroup() %>%
    unnest_wider(results) %>% # add fields category, grade, limitations_list, breakpoints_source
    rename(phenotype=category) %>%
    rename(phenotype_limitations_list=limitations_list) %>%
    rename(phenotype_grade=grade) %>%
    rename(phenotype_breakpoints_source=breakpoints_source) %>%
    rename(phenotype_note=note)

  ## remove unnecessary combination rules
  combinations <- data %>% filter(marker_count>1) %>% arrange(marker_count) %>% pull(marker)

  cat(" Defining rules for marker combinations\n")
  for (combo in combinations) {

    # get category calls from individual rules
    marker_names <- unlist(str_split(combo, ", "))
    individual_rules <- data %>% filter(marker %in% marker_names)

    # rules for subsets of this combination
    subset_rules <- data %>%
      filter(marker %in% compareSets(marker_names, data %>% filter(marker_count>1) %>% pull(marker), ", ")) %>%
      bind_rows(individual_rules) %>%
      filter(marker != combo)

    # get highest call (R>I>S) for any subset of this combination
    if (length(na.omit(subset_rules$`clinical category`))>0) {
      highest_individual_call <- max(AMR::as.sir(subset_rules$`clinical category`), na.rm=T)
    }
    else(highest_individual_call <- NA)

    # check if any subset are recorded as nonwildtype
    if ("NWT" %in% subset_rules$phenotype) {highest_pheno_call <- "NWT"}
    else {highest_pheno_call <- "WT"}

    # remove the rule if not needed
    combo_rule <- data %>% filter(marker==combo)
    if (is.na(combo_rule$`clinical category`) & is.na(combo_rule$phenotype)) { # no call to make, remove
      data <- data %>% filter(marker!=combo)}
    else {
      if (!is.na(highest_individual_call) & !is.na(combo_rule$`clinical category`))  { # subrules to compare to
        if (combo_rule$`clinical category` <= highest_individual_call) {
          data <- data %>% filter(marker!=combo) # interpretation no different to subrules
        }
      } else if (!is.na(highest_pheno_call) & !is.na(combo_rule$phenotype)) {
        if (combo_rule$phenotype=="WT" | combo_rule$phenotype==highest_pheno_call) {
          data <- data %>% filter(marker!=combo) # interpretation no different to subrules
        }
      }
    }
  }

  ## add rule IDs, update marker combinations to be expressed combinations of component marker ruleIDs
  data <- data %>% arrange(marker_count) %>%
    mutate(ruleID = paste0(rule_prefix,ruleID_start + row_number()), .before=marker)

  data <- data %>% rowwise() %>% mutate(gene = getGenes(data, combo=marker)) %>% ungroup()

  # summarise sources of pheno data
  if (!is.null(amrrules$info)) {
    if ("source" %in% colnames(amrrules$info)) {
      cat(" Enumerating sources\n")
      data <- enumerate_source_info(data=data, info=amrrules$info, amr_binary=amrrules$amr_binary, solo_binary=amrrules$solo_binary, column="source", use_mic=use_mic, use_disk=use_disk)
    }
    else { # these fields are used to summarise evidence limitations
      data <- add_missing_cols(data, c("solo.sources", "solo.sources.SIR", "mic.sources", "mic.sources.SIR", "mic.x.sources", "mic.x.sources.SIR", "disk.sources", "disk.sources.SIR"))
    }
  } else {
    cat("  No info file provided, can't enumerate sources\n")
    data <- add_missing_cols(data, c("solo.sources", "solo.sources.SIR", "mic.sources", "mic.sources.SIR", "mic.x.sources", "mic.x.sources.SIR", "disk.sources", "disk.sources.SIR"))
  }

  ## clean up rule fields and notes

  # gene info
  gene_info <- amrrules$afp_hits %>%
    #mutate(context=if_else(freq>core_threshold, "core", "accessory")) %>% # need to review wrt manual rules and hierarchy
    mutate(mutation=if_else(is.na(mutation), "-", mutation)) %>%
    mutate(marker=as.character(marker.label)) %>% # to match HGVS formatted labels in the input stats
    ungroup() %>%
    select(marker, freq, freq_n, mutation, node, `variation type`) %>% # exclude context
    distinct()

  # clean up fields as per AMRrules spec v0.6

  cat(" Cleaning up fields to match AMRrules spec v0.6\n")

  data <- data %>% left_join(gene_info, by="marker") %>%
    mutate(gene=if_else(marker_count>1, gene, node)) %>% # pull gene from ruleID combination for combo rules, otherwise node name from gene_info
    mutate(organism = paste0("s__",AMR::mo_fullname(as.mo(species)))) %>%
    mutate(drug=AMR::ab_name(as.ab(antibiotic)))

  data <- data %>%
    rowwise() %>%
    mutate(`evidence limitations`=paste(unique(unlist(list(phenotype_limitations_list, category_limitations_list))),collapse=" ")) %>%
    ungroup() %>%
    mutate(`evidence grade`=case_when(category_grade=="low" | phenotype_grade=="low" ~ "low",
                                      category_grade=="moderate" | phenotype_grade=="moderate" ~ "moderate", # only evaluated if none are low
                                      TRUE ~ NA # only evaluated if neither are low or moderate, ie both are NA
    ))

  # collate notes
  data <- data %>%
    rowwise() %>%
    mutate(note=paste(unique(unlist(list(phenotype_note, category_note))),collapse=" ")) %>%
    ungroup()

  note_cols <- c("R.solo.note", "I.solo.note", "NWT.solo.note", "mic_note", "disk_note", "R.soloExt.note", "I.soloExt.note", "NWT.soloExt.note")
  existing_cols <- note_cols[note_cols %in% names(data)]

  data <- data %>%
    rowwise() %>%
    mutate(dat_note = {
        notes <- c_across(all_of(existing_cols))
        notes[notes == ""] <- NA
        paste(na.omit(notes), collapse = " ")
      }) %>%
    ungroup() %>%
    mutate(`rule curation note`=paste(note, dat_note))


  # record breakpoints/ecoff for MIC/disk if assay data contributed to the rule
  data <- data %>%
    mutate(breakpoint_mic = case_when(is.null(!!mic_S) | is.null(!!mic_R) ~ "",
                                    `clinical category`=="S" ~ paste("MIC <=", mic_S, "mg/L"),
                                    `clinical category`=="R" ~ paste("MIC >", mic_R, "mg/L"),
                                    `clinical category`=="I" & expected_I ~ paste("MIC <=", mic_R, "mg/L"),
                                    `clinical category`=="I" & !expected_I ~ paste("MIC >", mic_S, "& <=", mic_R, "mg/L"),
                                    TRUE ~ "")) %>%
    mutate(breakpoint_disk = case_when(is.null(!!disk_S) | is.null(!!disk_R) ~ "",
                                      `clinical category`=="S" ~ paste("disk zone >=", disk_S, "mm"),
                                      `clinical category`=="R" ~ paste("disk zone <", disk_R, "mm"),
                                      `clinical category`=="I" & expected_I ~ paste("disk zone >=", disk_R, "mm"),
                                      `clinical category`=="I" & !expected_I ~ paste("disk zone >=", disk_R, "& <", disk_S, "mm"),
                                      TRUE ~ "")) %>%
    rowwise() %>%
    mutate(breakpoint=breakpoints(breakpoint_mic, breakpoint_disk, category_breakpoints_source, mic.sources, disk.sources)) %>%
    ungroup %>%
    mutate(`breakpoint standard`=if_else(breakpoint!="", guide, "")) %>%
    mutate(ecoff_mic=case_when(is.null(!!mic_ecoff) ~ "",
                                      phenotype=="WT" ~ paste("MIC <=", mic_ecoff, "mg/L"),
                                      phenotype=="NWT" ~ paste("MIC >", mic_ecoff, "mg/L"),
                                      TRUE ~ "")) %>%
    mutate(ecoff_disk=case_when(is.null(!!disk_ecoff) ~ "",
                                        phenotype=="WT" ~ paste("disk zone >=", disk_ecoff, "mm"),
                                        phenotype=="NWT" ~ paste("disk zone <", disk_ecoff, "mm"),
                                        TRUE ~ "")) %>%
    rowwise() %>%
    mutate(ecoff=breakpoints(ecoff_mic, ecoff_disk, phenotype_breakpoints_source, mic.sources, disk.sources)) %>%
    ungroup() %>%
    mutate(`ecoff standard`=if_else(ecoff!="", guide, "")) %>%
    mutate(phenotype=case_when(phenotype=="WT" ~ "wildtype",
                               phenotype=="NWT" ~ "nonwildtype",
                               TRUE ~ NA))

  rules <- data %>%
    mutate(date_stamp=format(Sys.time(), "%Y-%m-%d %H:%M:%S")) %>%
    mutate(`evidence code`=if_else(!is.na(`clinical category`), "ECO:0001103 natural variation mutant evidence", "")) %>%
    select(ruleID, organism, gene, node, mutation, `variation type`,
           drug, phenotype, `clinical category`,
           breakpoint, `breakpoint standard`, ecoff, `ecoff standard`,
           `evidence code`, `evidence grade`, `evidence limitations`,
           `rule curation note`, date_stamp,
           # quantitative data columns, not part of rule spec:
           any_of(c("marker",
                    "R.solo.ppv", "R.solo.n", "R.solo.x",
                    "I.solo.ppv", "I.solo.n", "I.solo.x",
                    "NWT.solo.ppv", "NWT.solo.n", "NWT.solo.x",
                    "R.soloExt.ppv", "R.soloExt.n", "R.soloExt.x",
                    "I.soloExt.ppv", "I.soloExt.n", "I.soloExt.x",
                    "NWT.soloExt.ppv", "NWT.soloExt.n", "NWT.soloExt.x",
                    "solo.sources", "solo.sources.SIR", "solo.methods", "solo.methods.SIR",
                    "MIC.n", "R.MIC.ppv", "MIC.R", "I.MIC.ppv", "MIC.I", "NWT.MIC.ppv", "MIC.NWT",
                    "MIC.n_excludeRangeValues", "MIC.median", "MIC.q25", "MIC.q75",
                    "mic.sources", "mic.sources.SIR", "mic.methods", "mic.methods.SIR",
                    "mic.x.sources", "mic.x.sources.SIR", "mic.x.methods", "mic.x.methods.SIR",
                    "Disk.n", "R.Disk.ppv", "Disk.R", "I.Disk.ppv", "Disk.I", "NWT.Disk.ppv", "Disk.NWT",
                    "Disk.median", "Disk.q25", "Disk.q75",
                    "disk.sources", "disk.sources.SIR", "disk.methods", "disk.methods.SIR",
                    "R.logreg.est", "R.logreg.ci.lower", "R.logreg.ci.upper", "R.logreg.pval",
                    "NWT.logreg.est", "NWT.logreg.ci.lower", "NWT.logreg.ci.upper", "NWT.logreg.pval",
                    "R.logregExt.est", "R.logregExt.ci.lower", "R.logregExt.ci.upper", "R.logregExt.pval",
                    "NWT.logregExt.est", "NWT.logregExt.ci.lower", "NWT.logregExt.ci.upper", "NWT.logregExt.pval",
                    "freq", "freq_n"))) %>%
    rename(nodeID=node) %>%
    mutate(across(everything(), ~ ifelse(is.na(.), "-", .))) %>%
    mutate(across(everything(), ~ ifelse(.=="", "-", .)))

  return(list(data=data, rules=rules))
}
