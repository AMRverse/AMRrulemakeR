#' Create AMR Rules Based on Geno-Pheno Data
#'
#' This function generates AMRrules based on genotype-phenotype data.
#' The rules are created initially for single markers using solo PPV and median MIC/disk assay data in comparison to
#' the defined breakpoints and ECOFFs (either user-specified, or retrieved using the AMR package), and then
#' rules for combinations of markers are added if the phenotypes associated with the combination are more resistant
#' (R>I>S, nonwildtype>wildtype) than for the individual component markers.
#'
#' @param amrrules A list containing AMR analysis results, generated by `amrrules_analysis`.
#' @param minObs Minimum number of observations (samples) required for a given marker/combination, in order for PPV or assay data to be considered in rule setting. Default is 3.
#' @param weak_threshold Minimum number of observations required for `evidence grade` to be assigned as "moderate" rather than "weak". Default is 20.
#' @param core_threshold The threshold used to classify a gene as "core" based on its frequency in the sample set. Default is 0.9 (90%).
#' @param use_mic Logical indicating whether to use MIC data in rule generation. Default is `TRUE`.
#' @param mic_S The MIC S breakpoint. If `NULL`, breakpoints will be retrieved using the AMR package.
#' @param mic_R The MIC R breakpoint. If `NULL`, breakpoints will be retrieved using the AMR package
#' @param mic_ecoff The MIC ECOFF for the antibiotic, used to define nonwildtype. If `NULL`, ECOFF will be retrieved using the AMR package.
#' @param use_disk Logical indicating whether to use disk diffusion data for rule generation. Default is `TRUE`.
#' @param disk_S The disk diffusion S breakpoint. If `NULL`, breakpoints will be retrieved using the AMR package.
#' @param disk_R The disk diffusion R breakpoint. If `NULL`, breakpoints will be retrieved using the AMR package.
#' @param disk_ecoff The disk diffusion ECOFF for the antibiotic, used to define nonwildtype. If `NULL`, ECOFF will be retrieved using the AMR package.
#' @param guide The guideline to use for breakpoints, when retrieving these from the AMR package. Default is `"EUCAST 2025"`.
#' @param bp_site Site of infection, used if multiple breakpoint values are available for different body sites.
#' @param rule_prefix Prefix for the generated rule IDs. If `NULL`, prefix will be assigned based on the species name.
#' @param ruleID_start The starting ID number for generated rules. Default is 1000.
#' @param note_prefix Prefix for the note describing the method used to create the rules. Default is `"Quantitative geno-pheno analysis by ESGEM-AMR WG"`.
#' @param regression Logical indicating whether to consider logistic regression data (only used to define wildtype S for an individual marker, where the p-value exceeds 0.05 and odds ratio crosses 0, and there is no solo-marker data available). Default is `TRUE`.
#'
#' @return A list containing 2 data frames:
#'   - `rules`: The draft rules in AMRrules format (spec v0.5), with some additional quantitative data fields to support review.
#'   - `data`: Full set of quantitative data fields used to draft the rules.
#'
#' @details
#' The `makerules` function generates AMR rules based on quantitative analysis of genotype vs phenotype data.
#' The rules can be based on MIC or disk diffusion assay results, and different thresholds are applied to assign
#' evidence grades and limitations based on the quantiative data available, according to the AMRrules v0.5 specification.
#' A detailed `rule curation note` is included in the output `rules` dataframe, summarising the quantitative
#' data supporting each rule.
#' Full data on each marker/combination is also returned in the separate `data` dataframe.
#'
#' @examples
#' \dontrun{
#' # Example of creating AMR rules
#' amrrules <- amrrules_analysis(geno_table, pheno_table, antibiotic = "Ciprofloxacin",
#'                               drug_class_list = c("Quinolones"), species = "E. coli")
#' rules <- makerules(amrrules, minObs = 5, weak_threshold = 25, core_threshold = 0.85)
#' }
#'
#' @seealso
#' \code{\link{amrrules_analysis}} for generating the AMR analysis data that is input into `makerules`.
#'
#' @import dplyr
#' @import ggplot2
#' @importFrom AMR as.ab as.mo intrinsic_resistant
#'
#' @export
makerules <- function(amrrules, minObs=3, weak_threshold=20, core_threshold=0.9,
                      use_mic=TRUE, mic_S=NULL, mic_R=NULL, mic_ecoff=NULL,
                      use_disk=TRUE, disk_S=NULL, disk_R=NULL, disk_ecoff=NULL,
                      guide="EUCAST 2025", bp_site=NULL, rule_prefix=NULL, ruleID_start=1000,
                      note_prefix="Quantitative geno-pheno analysis by ESGEM-AMR WG",
                      regression=TRUE) {

  ## setup

  antibiotic <- amrrules$antibiotic

  species <- amrrules$species

  cat(paste("Generating AMRrules for", antibiotic, "in", species,"\n"))

  check_ruleID_start <- as.integer(ruleID_start)
  if(is.na(check_ruleID_start)) {stop(paste("Need valid integer to start numbering rules, specified via 'ruleID_start':", ruleID_start,"is not valid"))}

  # check if we have a valid ruleID prefix
  if(is.null(rule_prefix)) {
    rule_prefix <- organism_codes %>% filter(mo==as.mo(species)) %>% pull(Prefix) # try using species
    if (is_empty(rule_prefix)) {
      genus <- microorganisms %>% filter(mo==as.mo(species)) %>% pull(genus) # try using genus
      rule_prefix <- organism_codes %>% filter(mo==as.mo(genus)) %>% pull(Prefix)
    }
    if (is_empty(rule_prefix)) {
      stop(paste("Could not determine valid rule ID prefix to use based on the species name:", species, "- please specify directly using 'rule_prefix'"))
    }
    else{cat(paste("  Determined rule ID prefix:",rule_prefix,"\n"))}
  }
  else{cat(paste("  Using user-specified rule ID prefix:",rule_prefix,"\n"))}

  # prepare breakpoints
  bp_standard_mic <- "" # suffix to add to the breakpoint standard recorded in rules
  if(!is.null(mic_S) & !is.null(mic_R) & !is.null(bp_site)) {bp_standard_mic <- paste0("(", bp_site, ")")} # if breakpoints are provided and a site is noted, record this

  bp_standard_disk <- "" # suffix to add to the breakpoint standard recorded in rules
  if(!is.null(disk_S) & !is.null(disk_R) & !is.null(bp_site)) {bp_standard_disk <- paste0("(", bp_site, ")")} # if breakpoints are provided and a site is noted, record this

  # retrieve MIC breakpoints/ECOFF if needed
  if (use_mic) {

    # check we have MIC data
    if (is.null(amrrules$upset_mic_summary)) {stop("'use_mic' set to TRUE but there are is no MIC summary data ($upset_mic_summary) in the input object")}
    if (nrow(amrrules$upset_mic_summary %>% filter(marker_count>0))==0) {stop("'use_mic' set to TRUE but the MIC summary data ($upset_mic_summary) in the input object is empty")}

    if (is.null(mic_S) | is.null(mic_R)) { # determine MIC breakpoints
      bp <-checkBreakpoints(species, guide, antibiotic, bp_site, bp_standard_mic, assay="MIC")
      mic_S <- bp$breakpoint_S
      mic_R <- bp$breakpoint_R
      bp_standard_mic <- bp$bp_standard
    }
    else{cat(paste("  Using user-specified MIC breakpoints: S <=", mic_S,"and R >", mic_R,"\n"))}

    if (is.null(mic_ecoff)) { # determine MIC ECOFF
      ecoffs <- getBreakpoints(species, guide, antibiotic, "ECOFF") %>% filter(method=="MIC")
      if (nrow(ecoffs)==0) {
        cat("  Could not determine MIC ECOFF using AMR package, using S breakpoint, consider providing your own value via 'mic_ecoff'\n")
        mic_ecoff <- mic_S
      }
      else {
        mic_ecoff <- ecoffs %>% pull(breakpoint_S) %>% first()
        if (is.na(mic_ecoff)) {
          cat("  Could not determine MIC ECOFF using AMR package, using S breakpoint, consider providing your own value via 'mic_ecoff'\n")
          mic_ecoff <- mic_S
        }
        else{cat(paste("  MIC ECOFF determined using AMR package:", mic_ecoff,"\n"))}
      }
    }
    else{cat(paste("  Using user-specified MIC ECOFF:", mic_ecoff,"\n"))}
  }

  # retrieve disk breakpoints/ECOFF if needed
  if (use_disk) {

    # check we have disk data - don't stop but warn, and set use_disk to false if none available
    if (is.null(amrrules$upset_disk_summary)) {
      cat("  WARNING: 'use_disk' set to TRUE but there are is no disk summary data ($upset_disk_summary) in the input object\n")
      use_disk=F
    }
    else if (nrow(amrrules$upset_disk_summary %>% filter(marker_count>0))==0) {
      cat("  WARNING: 'use_disk' set to TRUE but the disk summary data ($upset_disk_summary) in the input object is empty\n")
      use_disk=F
    }
  }

  if (use_disk) {
    if (is.null(disk_S) | is.null(disk_R)) { # determine disk diffusion breakpoints
      bp <-checkBreakpoints(species, guide, antibiotic, bp_site, bp_standard_disk, assay="DISK")
      disk_S <- bp$breakpoint_S
      disk_R <- bp$breakpoint_R
      bp_standard_disk <- bp$bp_standard
    }
    else{cat(paste("  Using user-specified disk breakpoints: S >=", disk_S,"and R <", disk_R,"\n"))}

    if (is.null(disk_ecoff)) { # determine disk ECOFF
      ecoffs <- getBreakpoints(species, guide, antibiotic, "ECOFF") %>% filter(method=="DISK")
      if (nrow(ecoffs)==0) {
        cat("  Could not determine disk ECOFF using AMR package, using S breakpoint, consider providing your own value via 'disk_ecoff'\n")
        disk_ecoff <- disk_S
      }
      else {
        disk_ecoff <- ecoffs %>% pull(breakpoint_S) %>% first()
        if (is.na(disk_ecoff)) {
          cat("  Could not determine disk ECOFF using AMR package, using S breakpoint, consider providing your own value via 'disk_ecoff'\n")
          disk_ecoff <- disk_S
        }
        else{cat(paste("  Disk ECOFF determined using AMR package:", disk_ecoff,"\n"))}
      }
    }
    else{cat(paste("  Using user-specified disk ECOFF:", disk_ecoff,"\n"))}
  }
  
  # check if this drug is an expected R or I in this species
  expected_R <- as.ab(antibiotic) %in% (intrinsic_resistant %>% filter(mo==as.mo(species)) %>% pull(ab))
  if (expected_R) {cat(paste(" ",antibiotic,"is an expected resistance for",species,"\n"))}
  
  expected_I <- FALSE
  if(!expected_R) { # if expected I, the MIC S breakpoint is set to 0.001 (i.e. there is effectively no S category as all isolates exceed this value)
    if (!is.null(mic_S)) {if (mic_S==0.001) {expected_I <- TRUE}}
    if (!is.null(disk_S)) {if (disk_S==50) {expected_I <- TRUE}}
  }
  if (expected_I) {cat(paste(" ",antibiotic,"is an expected I for",species, "(there is no S category)\n"))}
  

  ## load quantitative data

  # solo PPV data (for individual markers, found solo in at least minObs genomes)
  data <- amrrules$solo_stats %>%
    filter(n>=minObs & !is.na(x)) %>%
    pivot_wider(id_cols=marker, names_from=category, values_from=c(ppv, x, n, ci.lower, ci.upper),
                names_glue= "{category}.ppv.{.value}") %>%
    rename(R.ppv=R.ppv.ppv, NWT.ppv=NWT.ppv.ppv) %>%
    mutate(Rppv_note=paste0("R PPV=", round(R.ppv,2)*100, "% (",R.ppv.x,"/",R.ppv.n,"). ")) %>%
    mutate(NWTppv_note=paste0("NWT PPV=", round(NWT.ppv,2)*100, "% (",NWT.ppv.x,"/",NWT.ppv.n,"). "))

  # logistic regression data (for individual markers)
  if (regression) {
    logreg_data <- amrrules$modelR %>%
      mutate(marker=gsub("`","", marker )) %>%
      filter(marker!="(Intercept)") %>%
      rename_with(~paste0("LogRegR.", .x))
    data <- data %>% full_join(logreg_data, join_by(marker==LogRegR.marker))

    logreg_data <- amrrules$modelNWT %>%
      mutate(marker=gsub("`","", marker )) %>%
      filter(marker!="(Intercept)") %>%
      rename_with(~paste0("LogRegNWT.", .x))
    data <- data %>% full_join(logreg_data, join_by(marker==LogRegNWT.marker))
  }

  # add MIC data (for individual markers and combinations, with at least minObs genomes) and create info note
  if (use_mic) {
    # remove any rows where the MIC data was all expressed as ranges, ie median is NA
    mic_data <- amrrules$upset_mic_summary %>%
      filter(marker_list!="") %>%
      filter(!is.na(median) & n>=minObs) %>%
      rename_with(~paste0("MIC.", .x))

    data <- data %>% full_join(mic_data, join_by(marker==MIC.marker_list)) %>%
      mutate(mic_note=paste0("MIC: median ",MIC.median," [IQR ",MIC.q25,"-",MIC.q75,"]","; n=",MIC.n, ". "))
  }
  else {data <- data %>% mutate(MIC.median=NA, MIC.n=NA, mic_note=NA)}

  # add disk data (for individual markers and combinations, with at least minObs genomes) and create info note
  if (use_disk) {
    disk_data <- amrrules$upset_disk_summary %>%
      filter(marker_list!="") %>%
      filter(!is.na(median) & n>=minObs) %>%
      rename_with(~paste0("Disk.", .x))

    data <- data %>% full_join(disk_data, join_by(marker==Disk.marker_list)) %>%
      mutate(disk_note=paste0("Disk: median ",Disk.median," [IQR ",Disk.q25,"-",Disk.q75,"]","; n=",Disk.n, ". "))
  }
  else {data <- data %>% mutate(Disk.median=NA, Disk.n=NA, disk_note=NA)}

  # add rules for any markers detected, but not already accounted for (ie not found solo or with logistic regression data)
  col <- gsub("\\.\\.", ":", colnames(amrrules$amr_binary)) # get column names, fix .. to :
  cols_to_remove <- c("id", "mic", "disk", "R", "NWT", "pheno", "source")
  genes <- setdiff(col, cols_to_remove)
  genes_to_add <- setdiff(genes, data$marker)

  blank_rules <- tibble(marker = genes_to_add)

  data <- data %>% full_join(blank_rules, by="marker") %>%
    mutate(marker_count = str_count(marker, ",")+1)


  ## define categories and phenotypes using the collated data

  # clinical category based on solo PPV (solo markers only)
  data <- data %>% mutate(category_soloPPV = case_when(R.ppv>=0.8 ~ "R",
                                                         NWT.ppv<=0.5 ~ "S",
                                                         NWT.ppv>0.5 & (is.na(R.ppv) | R.ppv<0.8) ~ "I",
                                                         is.na(NWT.ppv) & R.ppv<=0.5 ~ "S",
                                                         is.na(NWT.ppv) & R.ppv>0.5 ~ "I",
                                                         NA ~ NA))

  # phenotype based on solo PPV (solo markers only)

  # default all S to wildtype
  data <- data %>% mutate(phenotype_soloPPV=if_else(category_soloPPV=="S", "wildtype", "nonwildtype")) # S:wt, I/R:nwt

  # if expected R, annotate R calls as wildtype and flag others for review
  if (expected_R) {
    data <- data %>% mutate(phenotype_soloPPV=if_else(category_soloPPV=="R", "wildtype", "REVIEW: expected R")) # R:wt, S/I:review
  }
  # if expected I, annotate I or R calls as wildtype and all others as wildtype
  else if (expected_I) {
    data <- data %>% mutate(phenotype_soloPPV=if_else(category_soloPPV =="I", "wildtype", phenotype_soloPPV)) # S/I:wt, R:nwt
  }

  # clinical category based on logistic regression (individual markers without solo PPV)
  if (regression) {
    data <- data %>% mutate(category_logReg=if_else(is.na(category_soloPPV) & LogRegR.pval>0.05 & LogRegR.ci.lower<0 & LogRegR.ci.upper>0, "S", NA)) %>%
      mutate(category_logRegNWT=if_else(is.na(category_soloPPV) & LogRegNWT.pval>0.05 & LogRegNWT.ci.lower<0 & LogRegNWT.ci.upper>0, "S", NA)) %>%
      mutate(category_logReg = if_else(category_logReg=="S" & category_logRegNWT=="S", "S", NA)) %>%
      mutate(phenotype_logReg=if_else(category_logReg=="S", "wildtype", NA)) %>%
      mutate(category_logReg = if_else(category_logReg=="S" & expected_I, "I", category_logReg)) %>%
      select(-category_logRegNWT)
  }
  else {data <- data %>% mutate(category_logReg=NA, phenotype_logReg=NA)}

  # call category and phenotype from MIC (individual markers and combinations)
  if (use_mic) {
    data <- data %>% mutate(category_MIC=case_when(is.na(MIC.median) ~ NA,
                                                   MIC.median>mic_R ~ "R",
                                                   MIC.median<=mic_S ~ "S",
                                                   MIC.median>mic_S & MIC.median<=mic_R ~ "I",
                                                   TRUE ~ NA)) %>%
                  mutate(phenotype_MIC=case_when(is.na(MIC.median) ~ NA,
                                           MIC.median>mic_ecoff ~ "nonwildtype",
                                           TRUE ~ "wildtype"))
  }
  else {data <- data %>% mutate(category_MIC=NA, phenotype_MIC=NA, MIC.median=NA)}

  # call category and phenotype from disk (individual markers and combinations)
  if (use_disk) {
    data <- data %>% mutate(category_disk=case_when(is.na(Disk.median) ~ NA,
                                                    Disk.median<disk_R ~ "R",
                                                    Disk.median>=disk_S ~ "S",
                                                    Disk.median<disk_S & Disk.median>=disk_R ~ "I",
                                                    TRUE ~ NA)) %>%
      mutate(phenotype_disk=case_when(is.na(Disk.median) ~ NA,
                                    Disk.median<disk_ecoff ~ "nonwildtype",
                                   TRUE ~ "wildtype"))
  }
  else {data <- data %>% mutate(category_disk=NA, phenotype_disk=NA, Disk.median=NA)}


  ## compare calls from different sources, note discrepancies (NOTE: could prioritise evidence from MIC vs disk based on count?)
  # assign call based on solo PPV first, where available (note this data is in the table only for those with ≥minObs genomes)
  data <- data %>% mutate(`clinical category` = case_when(!is.na(category_soloPPV) ~ category_soloPPV,
                                         use_mic & !is.na(category_MIC) ~ category_MIC,
                                         use_disk & !is.na(category_disk) ~ category_disk,
                                         !is.na(category_logReg) ~ category_logReg,
                                         TRUE~NA)) %>%
    mutate(catnote = if_else(!is.na(category_soloPPV), "Solo PPV.", "")) %>%
    mutate(catnote = if_else(use_mic & !is.na(category_MIC) & `clinical category`==category_MIC, paste(catnote, "MIC."), catnote)) %>%
    mutate(catnote = if_else(use_disk & !is.na(category_disk) & `clinical category`==category_disk, paste(catnote, "Disk."), catnote)) %>%
    mutate(catnote = if_else(use_mic & !is.na(category_MIC) & `clinical category`!=category_MIC, paste(catnote, "MIC disagrees."), catnote)) %>%
    mutate(catnote = if_else(use_disk & !is.na(category_disk) & `clinical category`!=category_disk, paste(catnote, "Disk disagrees."), catnote)) %>%
    mutate(catnote = if_else(regression & !is.na(category_logReg) & is.na(category_soloPPV) & is.na(category_disk) & is.na(category_MIC),
                             "logistic regression.", catnote)) %>%
    mutate(catnote = sub("^\\s+", "", catnote))%>%
    mutate(phenotype = case_when(use_mic & !is.na(phenotype_MIC) ~ phenotype_MIC,
                              use_disk & !is.na(phenotype_disk) ~ phenotype_disk,
                              !is.na(phenotype_soloPPV) ~ phenotype_soloPPV,
                              !is.na(phenotype_logReg) ~ phenotype_logReg,
                              TRUE~NA)) %>%
    mutate(phenote = if_else(use_mic & !is.na(phenotype_MIC) & phenotype==phenotype_MIC, "MIC.", "")) %>%
    mutate(phenote = if_else(use_disk & !is.na(phenotype_disk) & phenotype==phenotype_disk, paste(phenote, "Disk."), phenote)) %>%
    mutate(phenote = if_else(((!use_mic & !use_disk) | (is.na(phenotype_disk) & is.na(phenotype_MIC))) & !is.na(category_soloPPV), paste(phenote, "Solo PPV."), phenote)) %>%
    mutate(phenote = if_else(use_mic & use_disk & !is.na(phenotype_disk) & !is.na(phenotype_MIC) & phenotype_disk!=phenotype_MIC, paste(phenote, "Disk disagrees."), phenote)) %>%
    mutate(phenote = if_else(regression & !is.na(category_logReg) & is.na(category_soloPPV) & is.na(category_disk) & is.na(category_MIC),
                             "logistic regression.", phenote)) %>%
    mutate(phenote = sub("^\\s+", "", phenote))

  ## remove unnecessary combination rules
  combinations <- data %>% filter(marker_count>1) %>% arrange(marker_count) %>% pull(marker)

  for (combo in combinations) {

    # get category calls from individual rules
    marker_names <- unlist(str_split(combo, ", "))
    individual_rules <- data %>% filter(marker %in% marker_names)

    # rules for subsets of this combination
    subset_rules <- data %>%
      filter(marker %in% compareSets(marker_names, data %>% filter(marker_count>1) %>% pull(marker), ", ")) %>%
      bind_rows(individual_rules) %>%
      filter(marker != combo)

    # get highest call (R>I>S) for any subset of this combination
    if (length(na.omit(subset_rules$`clinical category`))>0) {
      highest_individual_call <- max(as.sir(subset_rules$`clinical category`), na.rm=T)
    }
    else(highest_individual_call <- NA)

    # check if any subset are recorded as nonwildtype
    if ("nonwildtype" %in% subset_rules$phenotype) {highest_pheno_call <- "nonwildtype"}
    else {highest_pheno_call <- "wildtype"}

    # remove the rule if not needed
    combo_rule <- data %>% filter(marker==combo)
    if (is.na(combo_rule$`clinical category`) & is.na(combo_rule$phenotype)) { # no call to make, remove
      data <- data %>% filter(marker!=combo)}
    else {
      if (!is.na(highest_individual_call) & !is.na(highest_pheno_call))  { # subrules to compare to
        if ((combo_rule$`clinical category` <= highest_individual_call) & (combo_rule$phenotype=="wildtype" | combo_rule$phenotype==highest_pheno_call)) {
          data <- data %>% filter(marker!=combo) # interpretation no different to subrules
    }}}

  }

  ## add rule IDs, update marker combinations to be expressed combinations of component marker ruleIDs
  data <- data %>% arrange(marker_count) %>%
    mutate(ruleID = paste0(rule_prefix,ruleID_start + row_number()), .before=marker)

  data <- data %>% rowwise() %>% mutate(gene = getGenes(data, combo=marker)) %>% ungroup()


  ## clean up rule fields and notes

  # gene info
  gene_info <- amrrules$afp_hits %>%
    rename(nodeID=`Hierarchy node`) %>%
    mutate(context=if_else(`Element subtype`=="AMR" & freq>core_threshold,
                           "core", "accessory")) %>%
    mutate(mutation=if_else(is.na(mutation), "-", mutation)) %>%
    select(-c(marker, `Element subtype`, `HMM id`)) %>%
    rename(marker=marker.label) %>% # to match HGVS formated labels in the input stats
    mutate(marker=as.character(marker)) # ensure this is a string for matching

  # summarise sources of pheno data
  if ("source" %in% colnames(amrrules$solo_binary)) {
    solo_sources <- amrrules$solo_binary %>%
      filter(!is.na(pheno) & !is.na(marker) & value==1) %>%
      select(source, marker) %>% distinct() %>%
      group_by(marker) %>% count(name="solo.sources")

    solo_sources_per_pheno <- amrrules$solo_binary %>%
      filter(!is.na(pheno) & !is.na(marker) & value==1) %>%
      select(source, marker, pheno) %>% distinct() %>%
      group_by(marker, pheno) %>% count(name="sources") %>%
      pivot_wider(names_from=pheno, names_prefix="solo.sources.", values_from=sources) %>%
      mutate(across(everything(), ~ ifelse(is.na(.), 0, .)))

    data <- data %>% left_join(solo_sources, by="marker") %>%
      left_join(solo_sources_per_pheno, by="marker")

    if (use_mic) {
      data <- data %>% rowwise() %>% mutate(source_info=getSources(amrrules$amr_binary, marker, "mic")) %>% unnest_wider(source_info) %>% ungroup()
    }

    if (use_disk) {
      data <- data %>% rowwise() %>% mutate(source_info=getSources(amrrules$amr_binary, marker, "disk")) %>% unnest_wider(source_info) %>% ungroup()
    }

    source_names <- c("sources", "sources.S", "sources.I", "sources.R")
    data <- add_missing_cols(data, c(paste0("solo.",source_names), paste0("disk.",source_names), paste0("mic.",source_names))) %>%
      mutate(solo.sources.SIR = if_else(!is.na(solo.sources),
                                        paste0(na0(solo.sources.S), " S, ", na0(solo.sources.I), " I, ", na0(solo.sources.R), " R"),
                                        "-")) %>%
      mutate(mic.sources.SIR = if_else(!is.na(mic.sources) & use_mic,
                                       paste0(na0(mic.sources.S), " S, ", na0(mic.sources.I), " I, ", na0(mic.sources.R), " R"),
                                       "-")) %>%
      mutate(disk.sources.SIR = if_else(!is.na(disk.sources) & use_disk,
                                        paste0(na0(disk.sources.S), " S, ", na0(disk.sources.I), " I, ", na0(disk.sources.R), " R"),
                                        "-"))
  }
  else {
    data <- add_missing_cols(data, c("solo.sources", "solo.sources.SIR", "mic.sources", "mic.sources.SIR", "disk.sources", "disk.sources.SIR"))
  }

  # clean up fields as per AMRrules spec v0.5
  rules <- data %>% left_join(gene_info, by="marker") %>%
    mutate(gene=if_else(marker_count>1, gene.x, gene.y)) %>% # pull gene from ruleID combination for combo rules, otherwise gene name from gene_info
    mutate(organism = paste0("s_",mo_fullname(as.mo(species)))) %>%
    mutate(drug=ab_name(as.ab(antibiotic))) %>%
    mutate(category_from_disk = if_else(grepl("Disk. MIC disagrees.", catnote), TRUE, FALSE)) %>%
    mutate(breakpoint=case_when(!category_from_disk & `clinical category`=="S" ~ paste("MIC <=", mic_S, "mg/L"),
                                !category_from_disk & `clinical category`=="R" ~ paste("MIC >", mic_R, "mg/L"),
                                !category_from_disk & `clinical category`=="I" & expected_I ~ paste("MIC <=", mic_R, "mg/L"),
                                !category_from_disk & `clinical category`=="I" & !expected_I ~ paste("MIC >", mic_S, "& <=", mic_R, "mg/L"),
                                category_from_disk & `clinical category`=="S" ~ paste("disk zone >=", disk_S, "mm"),
                                category_from_disk & `clinical category`=="R" ~ paste("disk zone <", disk_R, "mm"),
                                category_from_disk & `clinical category`=="I" & expected_I ~ paste("disk zone >=", disk_R, "mm"),
                                category_from_disk & `clinical category`=="I" & !expected_I ~ paste("disk zone >=", disk_R, "& <", disk_S, "mm"),
                                TRUE ~ "-"
    )) %>%
    mutate(`breakpoint standard`=case_when(!category_from_disk ~ paste0(guide, bp_standard_mic),
                                           category_from_disk ~ paste0(guide, bp_standard_disk),
                                           TRUE~"-")) %>%
    mutate(`breakpoint condition`=paste0(bp_site, bp_standard_mic)) %>% #TO CHECK
    mutate(`rule curation note`=paste0(note_prefix, ". ", marker, ". ")) %>%
    mutate(`rule curation note`=if_else(!is.na(`clinical category`),
                                        paste0(`rule curation note`, "Category call '", `clinical category`, "' based on ", catnote, " "),
                                        `rule curation note`)) %>%
    mutate(`rule curation note`=if_else(!is.na(phenotype),
                                        paste0(`rule curation note`, "Phenotype call '", phenotype, "' based on ", phenote, " "),
                                        `rule curation note`)) %>%
    mutate(`rule curation note`=if_else(!is.na(R.ppv), paste0(`rule curation note`, Rppv_note), `rule curation note`)) %>%
    mutate(`rule curation note`=if_else(!is.na(NWT.ppv), paste0(`rule curation note`, NWTppv_note), `rule curation note`)) %>%
    mutate(`rule curation note`=if_else(!is.na(R.ppv) & !is.na(solo.sources),
                                        paste0(`rule curation note`, solo.sources, " solo datasets: ", solo.sources.SIR, ". "),
                                        `rule curation note`))  %>%
    mutate(`rule curation note`=if_else(use_mic & !is.na(MIC.median), paste0(`rule curation note`, mic_note), `rule curation note`))%>%
    mutate(`rule curation note`=if_else(use_mic & !is.na(MIC.median) & !is.na(mic.sources),
                                        paste0(`rule curation note`, mic.sources, " MIC datasets: ", mic.sources.SIR, ". "),
                                        `rule curation note`)) %>%
    mutate(`rule curation note`=if_else(use_disk & !is.na(Disk.median), paste0(`rule curation note`, disk_note), `rule curation note`)) %>%
    mutate(`rule curation note`=if_else(use_disk & !is.na(Disk.median) & !is.na(disk.sources),
                                        paste0(`rule curation note`, disk.sources, " disk datasets: ", disk.sources.SIR, ". "),
                                        `rule curation note`)) %>%
    mutate(`rule curation note`=if_else(grepl("regression", catnote) & !is.na(LogRegR.est),
                                        paste0(`rule curation note`, "OR for R: ", round(exp(LogRegR.est),3), " [", round(exp(LogRegR.ci.lower),3),"-", round(exp(LogRegR.ci.upper),3),"], p=", sprintf("%.3e", LogRegR.pval), ". "),
                                        `rule curation note`)) %>%
    mutate(`rule curation note`=if_else(grepl("regression", catnote) & !is.na(LogRegNWT.est),
                                        paste0(`rule curation note`, "OR for NWT: ", round(exp(LogRegNWT.est),3), " [", round(exp(LogRegNWT.ci.lower),3),"-", round(exp(LogRegNWT.ci.upper),3),"], p=", sprintf("%.3e", LogRegNWT.pval), ". "),
                                        `rule curation note`)) %>%
    mutate(`evidence code`=if_else(!is.na(`clinical category`), "ECO:0001103 natural variation mutant evidence", "")) %>%
    mutate(`evidence grade`=if_else(R.ppv.n>=weak_threshold & grepl("PPV.", catnote), "moderate", "weak")) %>%
    mutate(`evidence grade`=if_else(MIC.n>=weak_threshold & grepl("MIC.", catnote), "moderate", `evidence grade`)) %>%
    mutate(`evidence grade`=if_else(Disk.n>=weak_threshold & grepl("Disk.", catnote), "moderate", `evidence grade`)) %>%
    mutate(`evidence limitations`=if_else(`evidence grade`=="weak", "Limited samples. ", "")) %>%
    mutate(`evidence grade`=if_else(grepl("disagrees", catnote), "weak", `evidence grade`)) %>%
    mutate(`evidence limitations`=if_else(grepl("disagrees", catnote),
                                          paste0(`evidence limitations`, "Conflicting evidence. "),
                                          `evidence limitations`)) %>%
    mutate(`evidence limitations`=if_else(catnote=="" | grepl("regression", catnote), "No solo geno-pheno data. ", `evidence limitations`)) %>%
    mutate(source_limitations=case_when(!is.na(solo.sources) & solo.sources < 3 & grepl("PPV.", catnote) ~ "Limited datasets.",
                                        !is.na(mic.sources) & mic.sources < 3 & grepl("MIC.", catnote) ~ "Limited MIC datasets.",
                                        !is.na(disk.sources) & disk.sources < 3 & grepl("Disk.", catnote) ~ "Limited disk datasets.",
                                        TRUE ~ "")) %>%
    mutate(`evidence limitations`=paste0(`evidence limitations`, source_limitations)) %>%
    mutate(date_stamp=format(Sys.time(), "%Y-%m-%d %H:%M:%S")) %>%
    select(ruleID, organism, gene, nodeID, mutation, `variation type`,
           context, drug, phenotype, `clinical category`, 
           breakpoint, `breakpoint standard`, `breakpoint condition`,
           `evidence code`, `evidence grade`, `evidence limitations`,
           `rule curation note`, date_stamp,
           # quantitative data columns, not part of rule spec:
           any_of(c("marker","R.ppv", "R.ppv.n", "R.ppv.x", "NWT.ppv", "NWT.ppv.n", "NWT.ppv.x", "solo.sources", "solo.sources.SIR",
           "MIC.n", "MIC.median", "MIC.q25", "MIC.q75", "mic.sources", "mic.sources.SIR",
           "Disk.n", "Disk.median", "Disk.q25", "Disk.q75", "disk.sources", "disk.sources.SIR",
           "LogRegR.est", "LogRegR.ci.lower", "LogRegR.ci.upper", "LogRegR.pval",
           "LogRegNWT.est", "LogRegNWT.ci.lower", "LogRegNWT.ci.upper", "LogRegNWT.pval", "freq"))) %>%
    mutate(`refseq accession`="-",
           `GenBank accession`="-", 
           `HMM accession`="-", 
           `ARO accession`="-", .after=nodeID) %>%
    mutate(`drug class`="-", .after=drug) %>%
    mutate(across(everything(), ~ ifelse(is.na(.), "-", .)))

  return(list(data=data, rules=rules))
}
